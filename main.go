// main.go
package main

import (
	"bufio"
	cfcli "cs-cli/cf-cli"
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/term"

	"cs-cli/sso"
)

func main() {
	// Initialize embedded CF CLI
	cli, err := cfcli.New()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error initializing CF CLI: %v\n", err)
		os.Exit(1)
	}

	args := os.Args[1:]

	// Intercept login --sso
	if len(args) >= 2 && args[0] == "login" && contains(args, "--sso") {
		if err := handleSSOLogin(cli, args); err != nil {
			fmt.Fprintf(os.Stderr, "SSO login failed: %v\n", err)
			os.Exit(1)
		}
		return
	}

	// Forward every other command directly to CF CLI
	if err := cli.Execute(args...); err != nil {
		os.Exit(1)
	}
}

func handleSSOLogin(cli *cfcli.EmbeddedCLI, args []string) error {
	// Resolve tenant-specific configuration
	loginURL, err := resolveLoginURL(cli, args)
	if err != nil {
		return err
	}

	fmt.Println("üîê Starting SSO authentication...")

	fmt.Println("üì± Opening browser for authentication...")
	if err := sso.OpenBrowser(loginURL + "/passcode"); err != nil {
		fmt.Printf("‚ö†Ô∏è  Unable to open the browser automatically\n")
		fmt.Printf("   Open manually: %s/passcode\n", loginURL)
	}
	fmt.Println("‚è≥ Paste the passcode generated by the CF page and press Enter.")
	passcode, err := readPasscodeFromStdin()
	if err != nil {
		return fmt.Errorf("cannot read passcode: %w", err)
	}

	fmt.Printf("‚úÖ Passcode received: %s\n", maskPasscode(passcode))

	// Remove --sso from the arguments and append --sso-passcode
	filteredArgs := filterArgs(args, "--sso", "login")
	finalArgs := append([]string{"login", "--sso-passcode", passcode}, filteredArgs...)

	// Execute cf login
	fmt.Println("üîÑ Executing login...")
	return cli.Execute(finalArgs...)
}

func readPasscodeFromStdin() (string, error) {
	fmt.Print("Passcode: ")

	fd := int(os.Stdin.Fd())
	var passcode string
	var err error

	if term.IsTerminal(fd) {
		bytes, readErr := term.ReadPassword(fd)
		fmt.Println()
		passcode = string(bytes)
		err = readErr
	} else {
		reader := bufio.NewReader(os.Stdin)
		passcode, err = reader.ReadString('\n')
	}

	if err != nil {
		return "", err
	}

	passcode = strings.TrimSpace(passcode)
	if passcode == "" {
		return "", errors.New("empty passcode")
	}

	return passcode, nil
}

func maskPasscode(passcode string) string {
	if len(passcode) <= 4 {
		return passcode
	}
	return passcode[:4] + strings.Repeat("*", len(passcode)-4)
}

func resolveLoginURL(cli *cfcli.EmbeddedCLI, args []string) (string, error) {
	if apiEndpoint := apiEndpointFromArgs(args); apiEndpoint != "" {
		return loginURLFromAPI(apiEndpoint)
	}

	if apiEndpoint, err := apiEndpointFromConfig(); err == nil && apiEndpoint != "" {
		return loginURLFromAPI(apiEndpoint)
	}

	// Final fallback: query `cf target`
	if loginURL, err := loginURLFromCLITarget(cli); err == nil && loginURL != "" {
		return loginURL, nil
	}

	return "", errors.New("unable to determine login URL: please specify the API endpoint with '-a' or configure the CF CLI")
}

func apiEndpointFromArgs(args []string) string {
	for i, arg := range args {
		if arg == "-a" || arg == "--api-endpoint" {
			if i+1 < len(args) {
				return strings.TrimSpace(args[i+1])
			}
		}

		if strings.HasPrefix(arg, "-a=") {
			return strings.TrimSpace(strings.TrimPrefix(arg, "-a="))
		}

		if strings.HasPrefix(arg, "--api-endpoint=") {
			return strings.TrimSpace(strings.TrimPrefix(arg, "--api-endpoint="))
		}
	}

	return ""
}

func buildLoginHost(apiHost string) string {
	host := apiHost
	if idx := strings.Index(host, ":"); idx != -1 {
		host = host[:idx]
	}

	if strings.HasPrefix(host, "api.") {
		return "login." + strings.TrimPrefix(host, "api.")
	}

	return "login." + host
}

func loginURLFromAPI(endpoint string) (string, error) {
	if endpoint == "" {
		return "", errors.New("empty API endpoint")
	}

	if !strings.Contains(endpoint, "://") {
		endpoint = "https://" + endpoint
	}

	parsed, err := url.Parse(endpoint)
	if err != nil {
		return "", fmt.Errorf("invalid API endpoint %q: %w", endpoint, err)
	}

	if parsed.Host == "" {
		return "", fmt.Errorf("API endpoint %q missing host", endpoint)
	}

	loginHost := buildLoginHost(parsed.Host)
	return fmt.Sprintf("%s://%s", parsed.Scheme, loginHost), nil
}

type cfConfig struct {
	Target string `json:"Target"`
}

func apiEndpointFromConfig() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}

	configPath := filepath.Join(home, ".cf", "config.json")
	data, err := os.ReadFile(configPath)
	if err != nil {
		return "", err
	}

	var cfg cfConfig
	if err := json.Unmarshal(data, &cfg); err != nil {
		return "", err
	}

	return strings.TrimSpace(cfg.Target), nil
}

func loginURLFromCLITarget(cli *cfcli.EmbeddedCLI) (string, error) {
	output, err := cli.ExecuteWithOutput("target")
	if err != nil {
		return "", err
	}

	lines := strings.Split(output, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(strings.ToLower(line), "api endpoint:") {
			parts := strings.SplitN(line, ":", 2)
			if len(parts) == 2 {
				endpoint := strings.TrimSpace(parts[1])
				return loginURLFromAPI(endpoint)
			}
		}
	}

	return "", errors.New("unable to detect API endpoint from target")
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func filterArgs(args []string, exclude ...string) []string {
	var filtered []string
	excludeMap := make(map[string]bool)
	for _, e := range exclude {
		excludeMap[e] = true
	}

	for _, arg := range args {
		if !excludeMap[arg] {
			filtered = append(filtered, arg)
		}
	}
	return filtered
}
